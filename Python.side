import numpy as np
import cv2 as cv
import glob
import board
from smbus2 import SMBus
from threading import Thread
from cv2 import aruco
import adafruit_character_lcd.character_lcd_rgb_i2c as character_lcd
import math

marker_size = 50
def send_message(message):
    message = [ord(character) for character in string]
    i4c.write_i2c_block_data(8,0, message)

def LCD_funct(a):
    lcd.message = a
#threading function
x = Thread(target = LCD_funct, args = (1,), daemon = True)
y = Thread(target = LCD_funct, args = (1,), daemon = True)
#I2c info
i2c = SMBus(1)
i4c = board.I2C()
#LCD funct.
lcd = character_lcd.Character_LCD_RGB_I2C(i4c, 2, 16)
lcd.clear

# termination criteria
criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)
 
# prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
objp = np.zeros((10*7,3), np.float32)
objp[:,:2] = np.mgrid[0:10,0:7].T.reshape(-1,2)
 
# Arrays to store object points and image points from all the images.
objpoints = [] # 3d point in real world space
imgpoints = [] # 2d points in image plane.
 
images = glob.glob('/home/seedlab/Pictures/*.jpg')
#initialize threading

x = Thread(target=LCD_funct, args = (1,), daemon = True)

x.start
for fname in images:
    img = cv.imread(fname)
    print("hello")
    # Find the chess board corners
    gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (10,7), None)
 
    # If found, add object points, image points (after refining them)
    if ret == True:
        print("HI")
        objpoints.append(objp)
        corners2 = cv.cornerSubPix(gray,corners, (11,11), (-1,-1), criteria)
        imgpoints.append(corners2)
 
        # Draw and display the corners
        cv.drawChessboardCorners(img, (10,7), corners2, ret)
        cv.imshow('img', img)
        cv.waitKey(500)
ret, mtx, dist, rvec, tvec = cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

print(mtx)

def calculate_angle(marker_center, image_center, distance):
    # Calculate the vector between the marker center and the image center
    vector_to_marker = marker_center - image_center
    
    # Calculate the angle using the arctangent function
    angle = np.arctan2(vector_to_marker,distance)*(180/np.pi)
    
    # Convert the angle from radians to degrees
    

    return angle

# Function to detect ArUco marker and draw the axis
def detect_aruco_marker(frame):
    # Convert the frame to grayscale
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)

    
    # Load the ArUco dictionary and parameters
    aruco_dict = aruco.getPredefinedDictionary(aruco.DICT_6X6_50)
    parameters = cv.aruco.DetectorParameters()
    
    # Detect markers in the frame
    corners, ids, _ = cv.aruco.detectMarkers(gray, aruco_dict, parameters=parameters)
    image = cv.aruco.drawDetectedMarkers(frame,corners,ids)
    # If markers are found, draw the axis and calculate the angle
    if ids is not None:
        for i in range(len(ids)):
            if ids is not None and len(ids)>0:
                marker_id = ids[0][0]
                revc,tvec,_ = aruco.estimatePoseSingleMarkers(corners, marker_size, mtx, dist)
                apparent_size = tvec[0][0][2]
                frame_undistorted = cv.undistort(frame, mtx, dist, None, mtx)
                centerx = image.shape[1]//2
                xsum = corners[0][0][0][0]+corners[0][0][1][0]+corners[0][0][2][0]+corners[0][0][3][0]
                markercenterx = xsum/4
                distance = tvec[0,0,2]
                angle = calculate_angle(markercenterx,centerx,distance)
                return angle
                           
                
        
        
            # Print the angle in treminal and onto LCD
        print(f"Angle with marker {ids[i][0]}: {angle} degrees")
        LCD_funct(str(angle))
            
    # Display the frame with the axis
    cv.imshow("Detected ArUco Marker", frame)

cap = cv.VideoCapture(0)


while True:
    ret, frame = cap.read()

    # Process the frame
    detect_aruco_marker(frame)
    LCD_funct("Scanning...")
    if ids is not None:
        #Send thestop
        lcd.clear()
        break
while True:
    detect_aruco_marker(frame)
    if ids is not None:
        angle = detect_aruco_marker(frame)
        #send the angle
        LCD_funct("On my Way!")
           


    # Break the loop if 'q' is pressed
    if cv.waitKey(1) & 0xFF == ord('q'):
        break

# Release the camera and close all windows
cap.release()
cv.destroyAllWindows()
