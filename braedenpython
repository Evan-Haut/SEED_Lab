import numpy as np
import cv2 as cv
from smbus2 import SMBus
from threading import Thread

# Constants for camera calibration and ArUco detection
mtx = np.array([[567.72602969, 0, 313.44143064],
                [0, 567.16356923, 233.64730096],
                [0, 0, 1]])
dist = np.array([0.26660512, -0.86434186, -0.00534246, 0.01027815, 1.58472904])
marker_size = 0.1  # Actual marker size in meters

# Initialize I2C communication
i2c = SMBus(1)
arduino_address = 8

# Function to send a message to Arduino
def send_message(message, is_angle=False):
    # Convert the angle message to bytes and append 'A' at the beginning
    message_bytes = [ord('A')] + [ord(char) for char in message] + [ord('\n')] if is_angle else [message]
    i2c.write_i2c_block_data(arduino_address, 0, message_bytes)
    print("Sent: " + ("Detection" if not is_angle else "Angle: " + message))

# Function to calculate the angle
def calculate_angle(marker_center, image_center, distance):
    vector_to_marker = marker_center - image_center
    angle = np.arctan2(vector_to_marker, distance) * (180 / np.pi)
    return float(angle)

# Function to detect ArUco markers
def detect_aruco_marker():
    detection_sent = False  # Local variable to ensure we only send the detection message once
    cap = cv.VideoCapture(0)

    # Check if the camera opened successfully
    if not cap.isOpened():
        print("Error: Camera could not be opened.")
        return

    aruco_dict = cv.aruco.getPredefinedDictionary(cv.aruco.DICT_6X6_50)
    parameters = cv.aruco.DetectorParameters()

    while True:
        ret, frame = cap.read()
        if not ret:
            print("Error: Can't receive frame (stream end?). Exiting ...")
            break

        # Convert to grayscale for detection
        gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
        # Debugging: print gray image type and shape
        print(f"Frame type: {type(gray)}, dtype: {gray.dtype}, shape: {gray.shape}")

        try:
            # Attempt to detect ArUco markers
            corners, ids, rejectedImgPoints = cv.aruco.detectMarkers(gray, aruco_dict, parameters)
        except Exception as e:
            # If detection fails, print the error and skip to the next frame
            print(f"Error during ArUco marker detection: {e}")
            continue

        if ids is not None and not detection_sent:
            # Marker detected for the first time, send detection message '1'
            send_message(1, is_angle=False)
            detection_sent = True  # Prevent sending the detection message again

        elif ids is not None and detection_sent:
            # Marker detected and we have sent detection message, now send the angle
            rvec, tvec, _ = cv.aruco.estimatePoseSingleMarkers(corners, marker_size, mtx, dist)
            if tvec is not None and len(tvec) > 0:
                # Get the angle and send it
                marker_center_x = np.mean(corners[0][0][:, 0])
                center_x = frame.shape[1] // 2
                angle = calculate_angle(marker_center_x, center_x, tvec[0][0][2])
                send_message(str(angle), is_angle=True)
                break  # Once angle is sent, no need to continue detection

        cv.imshow("Detected ArUco Marker", frame)

        # Break the loop if 'q' is pressed
        if cv.waitKey(1) & 0xFF == ord('q'):
            print("Quitting...")
            break

    cap.release()
    cv.destroyAllWindows()

# Start the ArUco detection in a separate thread
thread = Thread(target=detect_aruco_marker, daemon=True)
thread.start()
thread.join()
