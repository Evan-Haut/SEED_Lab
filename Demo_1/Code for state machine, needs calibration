#define ENCODER_OPTIMIZE_INTERRUPTS
#include <Encoder.h>

float r = 2.875;
float circ = (2 * PI * r);
float desired_feet = 10; //input
float desired_inches = desired_feet * 12;
float distance = desired_inches / circ * 2 * PI;
float robot_diameter = 12.0; //measure wheel to wheel later

float desired_angle = 0; //input in radians


// initialize desired position
float desired_position[2] = {0, 0}; 

// Gain, battery voltage
float Kp = 2.0;
float batteryVoltage = 7.8;

// Error and PWM both wheels 
float error[2]; 
float PWM[2]; 

//Constant
const float pi = 3.141592653589793238462643383279502884197;

//Encoder left and right 
Encoder motor1(2, 5); 
Encoder motor2(3, 6); 

// initialize encoder counts
long encoder_count[2]; 

// Enable pin
const int enablePin = 4;


// Voltage sign pins, 7 & 8
const int vsignPin7 = 7;
const int vsignPin8 = 8; 

// Motor voltage pins 9 & 10
const int motorPin[2] = {9, 10}; 

// time variables
unsigned long desired_Ts_ms = 10; 
unsigned long last_time_ms;
unsigned long start_time;
float current_time;

// Motor velocity variables
float motorVelocity[2] = {0.0, 0.0}; 

// Motor voltage variables
float motorVoltage[2] = {0.0, 0.0}; 

// Previous count variables
long pos_counts_prev[2]; 

// Initialize previous radian variables
float pos_previous_rad[2]; 

// Initialize quadrant
////int quadrant;
int left_wheel;
int right_wheel;

// PI for position and speed for Vsum
float Kp_pos = 10.764; //calibrate
float Ki_pos = 2.6; //calibrate 
float Kp_speed = 2.0; //calibrate 
float Ki_speed = 0.1; //calibrate 

// Angle for Vdelta
float Kp_angle = 2; //calibrate
float Ki_angle = 0.1; //calibrate
float Kp_angular_speed = 1; //calibrate
float Ki_angular_speed = 0.01; //calibrate





float integral_error[2] = {0.0, 0.0}; 
float prev_error[2] = {0.0, 0.0}; 
// Variables for calculating position
long pos_counts[2];
float pos_rad[2];

//Vsum
float position_error;
float desired_speed;
float robot_current_heading;
float pos_robot;
float integral_error_position;
float integral_error_speed;
float speed_robot;
float speed_error;
float Vsum;


//Vdelta
float Vdelta;
float angle_error;
float integral_error_angle;
float angular_speed;
float robot_angular_speed;
float robot_angular_speed_error;
float integral_robot_angular_speed_error;







void setup() {
  // Baud rate 
  Serial.begin(115200);

  pinMode(vsignPin7, OUTPUT);
  pinMode(vsignPin8, OUTPUT);
  pinMode(motorPin[0], OUTPUT);
  // digitalWrite(motorPin[0], LOW); 
  pinMode(motorPin[1], OUTPUT);
  // digitalWrite(motorPin[1], LOW); 

  // Enable pin as pin 4, high
  pinMode(enablePin, OUTPUT);
  digitalWrite(enablePin, HIGH);

  // Previous counts and previous radians
  pos_counts_prev[0] = -motor1.read();
  pos_previous_rad[0] = 2 * pi * static_cast<float>(pos_counts_prev[0]) / 3200;
  pos_counts_prev[1] = -motor2.read();
  pos_previous_rad[1] = 2 * pi * static_cast<float>(pos_counts_prev[1]) / 3200;

  // Set up last time in milliseconds
  start_time = millis();
  
  
}

void loop() {

 
    current_time = (float)((millis() - start_time) / 1000.0);
    Serial.print(current_time);

    // find position in counts of wheel one using ISR functions
    pos_counts[0] = -motor1.read();

    pos_rad[0] = -2 * pi * (double)(pos_counts[0]) / (double)3200.0;

    // Calculate velocity for Motor 1
    motorVelocity[0] = (pos_rad[0] - pos_previous_rad[0]) / desired_Ts_ms;

    // find position in counts of wheel two using ISR functions
    pos_counts[1] = motor2.read();

    pos_rad[1] = -2 * pi * (double)(pos_counts[1]) / (double)3200;

    // Calculate velocity for Motor 2
    motorVelocity[1] = (pos_rad[1] - pos_previous_rad[1]) / desired_Ts_ms;

    // Set previous positions equal to current positions for the next iteration
    for (int i = 0; i < 2; i++) {
      pos_counts_prev[i] = pos_counts[i];
      pos_previous_rad[i] = pos_rad[i];
    }

//Vsum
    pos_robot = (pos_rad[0] + pos_rad[1])/2;
    position_error = distance - pos_robot;
    integral_error_position = integral_error_position + position_error * ((float)desired_Ts_ms / 1000);
    desired_speed = (Kp_pos * position_error) + (Ki_pos * integral_error_position);


    speed_robot = (motorVelocity[0] + motorVelocity[1]) / 2;
    speed_error = desired_speed - speed_robot;
    integral_error_speed = integral_error_speed + speed_error * ((float)desired_Ts_ms / 1000);
    Vsum = (Kp_speed * speed_error) + (Ki_speed * integral_error_speed);


//Vdelta
    robot_current_heading = ((pos_rad[1] - pos_rad[0])/(robot_diameter)) * r;
    angle_error = (desired_angle - robot_current_heading); 
    integral_error_angle = integral_error_angle + angle_error * ((float)desired_Ts_ms / 1000);
    angular_speed = (Kp_angle * angle_error) + (Ki_angle * integral_error_angle);

    robot_angular_speed = ((motorVelocity[1] - motorVelocity[0])/(robot_diameter)) * r;
    robot_angular_speed_error = (angular_speed - robot_angular_speed);
    integral_robot_angular_speed_error = integral_robot_angular_speed_error + robot_angular_speed_error * ((float)desired_Ts_ms / 1000);
    Vdelta = (Kp_angular_speed * robot_angular_speed_error) + (Ki_angular_speed * integral_robot_angular_speed_error);

//Motor Voltage 1 and 2
  motorVoltage[0] = Vsum - Vdelta;
  motorVoltage[1] = Vsum + Vdelta;
    // determine direction of motor voltages
  if (motorVoltage[0] <= 0) {
      digitalWrite(vsignPin7, HIGH); 
    } else {
      digitalWrite(vsignPin7, LOW); 
    }

  if (motorVoltage[1] <= 0) {
      digitalWrite(vsignPin8, HIGH); 
    } else {
      digitalWrite(vsignPin8, LOW); 
    }

    // calculate PWM
  //  motorVoltage[1] = 5;
    PWM[0] = 255 * abs(motorVoltage[0] / batteryVoltage);
    PWM[1] = 255 * abs(motorVoltage[1] / batteryVoltage);

    // analog write the PWM to the motors
    analogWrite(motorPin[1], min(PWM[0], 255));
    analogWrite(motorPin[0], min(PWM[1], 255));



  

if (current_time <= 50) {  

Serial.print("\n");
Serial.print("time ");
Serial.print(current_time); 
Serial.print("\t"); 
Serial.print("voltage1 ");
Serial.print((double)motorVoltage[0]);
Serial.print("\t"); 
Serial.print("voltage2 ");
Serial.print((double)motorVoltage[1]);
Serial.print("\t");

Serial.print("Vsum ");
Serial.print(Vsum);
Serial.print("\t");

Serial.print("Vdelta ");
Serial.print(last_time_ms);
Serial.print("\t");

//Serial.print("Distance2: ");
//Serial.print(actual_d1);

//Serial.print("\t");
//Serial.print("Distance1: ");
//Serial.print(actual_d1);

  }
  

  // Delay
  while (millis() < last_time_ms + desired_Ts_ms) {

}
last_time_ms = millis();
}
