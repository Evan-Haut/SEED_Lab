#define ENCODER_OPTIMIZE_INTERRUPTS
#include <Encoder.h>

const float pi = 3.14159;
float r = 2.8; //2.875 good
float circ = (2 * pi * r);
float desired_feet = 1; //input in feet
float desired_inches = desired_feet * 12;

float distance = desired_inches/ circ * 2 * pi; //revs of the wheel
//1 feet = 4.17391;
//float distance = 4.17391;
float robot_diameter = 15.0; //measure wheel to wheel later

//angle in radian

float desired_angle = 0; //input in radians 


// State Machine States
enum State { STOP, TURNING, MOVING };
State currentState = STOP;


// initialize desired position
float desired_position[2] = {0, 0}; 

// Gain, battery voltage
float Kp = 2.0;
float batteryVoltage = 7.8;

// Error and PWM both wheels 
float error[2]; 
float PWM[2]; 

//Constant


//Encoder left and right 
Encoder motor1(2, 5); 
Encoder motor2(3, 6); 

// initialize encoder counts
long encoder_count[2]; 

// Enable pin
const int enablePin = 4;


// Voltage sign pins, 7 & 8
const int vsignPin7 = 7;
const int vsignPin8 = 8; 

// Motor voltage pins 9 & 10
const int motorPin[2] = {9, 10}; 

// time variables
unsigned long desired_Ts_ms = 10; 
unsigned long last_time_ms;
unsigned long start_time;
float current_time;

// Motor velocity variables
float motorVelocity[2] = {0.0, 0.0}; 

// Motor voltage variables
float motorVoltage[2] = {0.0, 0.0}; 

// Previous count variables
long pos_counts_prev[2]; 

// Initialize previous radian variables
float pos_previous_rad[2]; 

// Initialize quadrant
////int quadrant;
int left_wheel;
int right_wheel;

// PI for position and speed for Vsum
float Kp_pos = 3.3; //calibrate 4.15 is better for now
float Ki_pos = 0.65; //calibrate 1.5/1.3
float Kp_speed = 0.1; //calibrate 0.1/0.04
float Ki_speed = 0.004; //calibrate 0.001/0.006

// Angle for Vdelta
float Kp_angle = 50; //calibrate 0.25/0.8/0.46 //1.8-angle error is 0.05
float Ki_angle = 0.65; //calibrate 0.001/0.1/0.0001
float Kp_angular_speed = 3; //calibrate 4.5/2.5  
float Ki_angular_speed = 1; //calibrate 0.1/0.01

// // PI for position and speed for Vsum
// float Kp_pos = 3.3; //calibrate 4.15 is better for now
// float Ki_pos = 0.65; //calibrate 1.5/1.3
// float Kp_speed = 0.4; //calibrate 0.1/0.04
// float Ki_speed = 0.004; //calibrate 0.001/0.006

// // // // Angle for Vdelta
// float Kp_angle = 9.3; //calibrate 0.25/0.8/0.46 //1.8-angle error is 0.05
// float Ki_angle = 0.65; //calibrate 0.001/0.1/0.0001
// float Kp_angular_speed = 6; //calibrate 4.5/2.5
// float Ki_angular_speed = 0; //calibrate 0.1/0.01

// // //Angle for Vdelta good for 45 degrees
// float Kp_angle = 0.25; //calibrate
// float Ki_angle = 0.001; //calibrate
// float Kp_angular_speed = 4.5; //calibrate
// float Ki_angular_speed = 0.1; //calibrate

float integral_error[2] = {0.0, 0.0}; 
float prev_error[2] = {0.0, 0.0}; 
// Variables for calculating position
long pos_counts[2];
float pos_rad[2];

//Vsum
float position_error;
float desired_speed;
float robot_current_heading;
float pos_robot;
float integral_error_position;
float integral_error_speed;
float speed_robot;
float speed_error;
float Vsum;


//Vdelta
float Vdelta;
//float angle_error;
float integral_error_angle;
float angular_speed;
float robot_angular_speed;
float robot_angular_speed_error;
float integral_robot_angular_speed_error;
void setup() {
  Serial.begin(9600);
  pinMode(motorPin[0], OUTPUT);
  pinMode(motorPin[1], OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(vsignPin7, OUTPUT);
  pinMode(vsignPin8, OUTPUT);
  
  digitalWrite(4, HIGH);

  // Initialize encoders
  motor1.write(0);
  motor2.write(0);

  // Initial State
  currentState = TURNING; // Start with turning
}

void loop() {
  // Debugging: Print current state
  //Serial.print("Current State: ");
  //Serial.println(currentState);

  switch (currentState) {
    case TURNING:
      turnToDesiredAngle(desired_angle);
      break;
    case MOVING:
      moveToDesiredDistance(distance);
      break;
    case STOP:
      stopMotors();
      break;
  }
}

void turnToDesiredAngle(float desired_angle) {
  delay(1000);
  double angleTolerance = 0.025; // Angle tolerance in radians //0.02 is 1 deg in radian //0.35 for 2
  double angle_error;

  do {
    // Read encoder counts
    pos_counts[0] = -motor1.read();
    pos_counts[1] = motor2.read();

    // Convert encoder counts to radians
    pos_rad[1] = -2 * pi * (double)(pos_counts[1]) / (double)3200;
    pos_rad[0] = -2 * pi * (double)(pos_counts[0]) / (double)3200;


    motorVelocity[0] = (pos_rad[0] - pos_previous_rad[0])/desired_Ts_ms;
    motorVelocity[1] = (pos_rad[1] - pos_previous_rad[1])/desired_Ts_ms;

        // Set previous positions equal to current positions for the next iteration
    for (int i = 0; i < 2; i++) {
      pos_counts_prev[i] = pos_counts[i];
      pos_previous_rad[i] = pos_rad[i];
       
    }

    // Calculate the robot's current heading
    robot_current_heading = ((pos_rad[1] - pos_rad[0]) / robot_diameter) * r;
    
    // Calculate the angle error
    angle_error = desired_angle - robot_current_heading;

    // Update integral of angle error
    integral_error_angle += angle_error * (desired_Ts_ms / 1000.0);

    // Calculate the desired angular speed
    angular_speed = (Kp_angle * angle_error) + (Ki_angle * integral_error_angle);

    // Calculate the robot's current angular speed
    robot_angular_speed = ((motorVelocity[1] - motorVelocity[0]) / robot_diameter) * r;

    // Calculate the error in angular speed
    robot_angular_speed_error = angular_speed - robot_angular_speed;

    // Update integral of angular speed error
    integral_robot_angular_speed_error += robot_angular_speed_error * (desired_Ts_ms / 1000.0);

    // Calculate Vdelta
    Vdelta = (Kp_angular_speed * robot_angular_speed_error) + (Ki_angular_speed * integral_robot_angular_speed_error);

    // Adjust motor voltages based on Vdelta
    motorVoltage[0] = Vdelta * 0.1;
    motorVoltage[1] = -Vdelta * 0.1;

    // Determine the direction of motor voltages and set the PWM values
    PWM[0] = 255 * abs(motorVoltage[0] / batteryVoltage);
    PWM[1] = 255 * abs(motorVoltage[1] / batteryVoltage);

    // Ensure the direction is correct for each motor
    digitalWrite(vsignPin7, motorVoltage[0] <= 0 ? HIGH : LOW);
    digitalWrite(vsignPin8, motorVoltage[1] <= 0 ? HIGH : LOW);

    // Write the PWM to the motors, ensuring the values do not exceed 255
    analogWrite(motorPin[1], min(PWM[0], 255));
    analogWrite(motorPin[0], min(PWM[1], 255));

    // Delay to maintain the desired control loop timing
    delay(desired_Ts_ms);
    Serial.print("Angle Error:");
    Serial.println(angle_error);
  } while (abs(angle_error) > angleTolerance);

  if (abs(angle_error <= angleTolerance)){
    analogWrite(motorPin[1], 0);
    analogWrite(motorPin[0], 0);

    //delay(10);
    currentState = MOVING;
    return;
  }
  //delay(0.5);
  // Delay
//   while (millis() < last_time_ms + desired_Ts_ms) {

// }
// last_time_ms = millis();
// }
// Stop the motors after the loop completes
//currentState = MOVING;
//delay(10); // Small delay for the motors to stabilize
// Transition to MOVING state after the desired angle is reached
}

void moveToDesiredDistance(float distance) {
  delay(1000);
  //Serial.println("In Desired Distance function");
  Serial.println(distance);
  double distanceTolerance = 0.5;
  double position_error;

  // Assume other necessary variables and constants like Kp_pos, Ki_pos, etc., are declared globally


  do{
    pos_counts[0] = motor1.read();
    pos_counts[1] = -motor2.read();

    // Convert encoder counts to radians
    pos_rad[1] = -2 * pi * (double)(pos_counts[1]) / (double)3200;
    pos_rad[0] = -2 * pi * (double)(pos_counts[0]) / (double)3200;


    motorVelocity[0] = (pos_rad[0] - pos_previous_rad[0])/desired_Ts_ms;
    motorVelocity[1] = (pos_rad[1] - pos_previous_rad[1])/desired_Ts_ms;

        // Set previous positions equal to current positions for the next iteration
    for (int i = 0; i < 2; i++) {
      pos_counts_prev[i] = pos_counts[i];
      pos_previous_rad[i] = pos_rad[i];
       
    }
    
    pos_robot = (pos_rad[0] + pos_rad[1]) / 2.0;
    
    position_error = distance - pos_robot;

   // Update integral of position error
    integral_error_position += position_error * (desired_Ts_ms / 1000.0);

    // Calculate the desired speed
    desired_speed = (Kp_pos * position_error) + (Ki_pos * integral_error_position);

    // Calculate the robot's current speed
    speed_robot = (motorVelocity[0] + motorVelocity[1]) / 2.0;

    // Calculate the speed error
    speed_error = desired_speed - speed_robot;

    // Update integral of speed error
    integral_error_speed += speed_error * (desired_Ts_ms / 1000.0);

    // Calculate Vsum
    Vsum = (Kp_speed * speed_error) + (Ki_speed * integral_error_speed);

    motorVoltage[0] = Vsum * 0.8;
    motorVoltage[1] = Vsum * 0.8;

    PWM[0] = 255 * abs(motorVoltage[0] / batteryVoltage);
    PWM[1] = 255 * abs(motorVoltage[1] / batteryVoltage);

    digitalWrite(vsignPin7, motorVoltage[0] <= 0 ? LOW : HIGH);
    digitalWrite(vsignPin8, motorVoltage[1] <= 0 ? LOW : HIGH);

    // Write the PWM to the motors, ensuring the values do not exceed 255
    analogWrite(motorPin[1], min(PWM[0], 255));
    analogWrite(motorPin[0], min(PWM[1], 255));

    // Delay to maintain the desired control loop timing
    delay(desired_Ts_ms);
    //Serial.print("Distance Error:");
    //Serial.println(abs(position_error));
  } while (abs(position_error) > distanceTolerance);

  if (abs(position_error) <= distanceTolerance){
    analogWrite(motorPin[1], 0);
    analogWrite(motorPin[0], 0);
    currentState = STOP;
    return;
  }
  // Delay
  while (millis() < last_time_ms + desired_Ts_ms) {
}
last_time_ms = millis();
}
  // currentState = STOP;

void stopMotors(){
  analogWrite(motorPin[0],0);
  analogWrite(motorPin[1],0);
  delay(10);
}
